java 正则表达式
一句话解释正则表达式
正则表达式，用于指定字符串模式，用它来查看字符串是否匹配某一个特定模式。

正则表达式案例
以前自己非常纠结正则表达式的种类，有如下两个比较主流的种类
POSIX 正则表达式：这是 UNIX 系统中常用的正则表达式标准，分为基本正则表达式（BRE）和扩展正则表达式（ERE）。
Perl 兼容正则表达式（PCRE）：这是在 Perl 编程语言中引入的正则表达式标准，许多现代语言和工具（如 PHP、JavaScript、Python 等）都采用了这种正则表达式。

java和js中的正则
正则表达式的匹配是从左到右进行的，通常是贪婪匹配（即尽可能多地匹配字符），除非使用了懒惰量词（如*?、+?等）
不需要纠结java和js中的正则是哪个种类，正则之间语法都比较类似，他们都属于功能比较强大的类型了

第一个示例
简单示例：
[Jj]ava.+ 

指定了三个条件：
第一个字母是 J 或 j，对应部分[Jj]
接下来的三个字母是 ava，对应部分ava。
字符串的其余部分由一个或多个任意字符组成，对应部分.+。
// 例如，字符串 "javanese" 匹配这个特定的正则表达式，但字符串 "Core Java" 不匹配。


简单正则表达式规则
想要用好正则表达式确实需要学一些东西。幸运的是，对于大多数用途，几个简单的构造就足够了。
在正则表达式中，字符本身表示自己，除非它是以下保留字符之一
. * + ? { | ( ) [ \ ^ $
// 话说右边的花括号 和 方括号 怎么不属于呢？？
例如，正则表达式 Java 仅匹配字符串 Java。
常用符号表示
符号 . 匹配任何单个字符。例如，.a.a 匹配 Java 和 data。
符号 * 表示前面的构造可以重复 0 次或多次；而 + 表示可以重复 1 次或多次。
后缀 ? 表示构造是可选的（0 次或 1 次）。
例如，be+s? 匹配 be、bee 和 bees。你可以使用 { } 指定其他的重复次数


如果深究正则表达式的语法，会发现非常复杂，这里仅仅提供一些常用的内容，作为参考
\c, where c is not in [AZa-z0-9] The character c \\
[C1C2 ...], where Ci are characters, ranges c-d, or character classes Any of the characters represented by C1 , C2 , ... [0-9+-]
[^...] Complement of a character class [^\d\s]
X{n}, X{n,}, X{m,n} n times X, at least n times X, between m and n times X [0-7]{1,3} are one to three octal digits


可选符号：符号 | 表示选择的可选项。例如，表达式 .(oo|ee)f 可以匹配 "beef" 或 "woof"。
注意括号的使用——如果没有括号，.oo|eef 将表示 .oo 和 eef 之间的替代。
// 在这里，圆括号仅仅只有一种效果就是表示被包围的内容是一个整体，此外，圆括号还可以用于分组捕获

字符类
字符类（Character Class）：字符类是用方括号括起来的一组字符可选项，例如 [Jj]（匹配大写或小写的 J）、[0-9]（匹配任何数字）、[A-Za-z]（匹配任何英文字母）或 [^0-9]（匹配任何非数字字符）。在字符类中，符号 - 表示一个范围，即所有 Unicode 值在两个边界之间的字符。然而，如果 - 是字符类的第一个或最后一个字符，它只表示自身。

预定义字符类 和 补集
有许多预定义的字符类，例如 \d（表示数字）或 \p{Sc}（表示 Unicode 货币符号）。
在字符类中，^ 作为第一个字符表示补集，即匹配所有未被指定的字符。

开头和结尾 转义特殊用户支付
字符 ^ 和 $ 匹配输入的开头和结尾。如果你需要使用字面意义上的 . * + ? { | ( ) [ \ ^ $，请在其前面加上反斜杠。
在字符类内部，你只需要转义 [ 和 \，前提是你注意 ] - ^ 的位置。例如，[]^-] 是一个包含这三者的类。

另外，可以用 \Q 和 \E 将字符串包围起来。例如，($0.99) 和 \Q($0.99)\E 都匹配字符串 ($0.99)。
\Q...\E Everything between the start and the end of the quotation \Q(...)\E matches the string (...)
// 就是为了精确的表示开头 和 结尾罢了

正则表达式分支，难以完全一统
不幸的是，正则表达式语法在各种程序和库之间并没有完全标准化；在基本结构上达成了一致，但在细节上存在许多令人困惑的差异。Java 的正则表达式类使用的语法与 Perl 语言中的语法相似，但并不完全相同。表 2.7 显示了 Java 语法的所有结构。有关正则表达式语法的更多信息，请查阅 Pattern 类的 API 文档或 Jeffrey E. F. Friedl 的书籍《Mastering Regular Expressions》（O’Reilly and Associates，2006）。
// 结论是 基本结构一致，但是细节上存在细微且令人困惑的差异


使用正则表达式的两种情况
1. 检查一个字符串是否符合这个表达式
2. 在一个字符串中找到所有符合正则表达式的匹配项。

匹配一整个字符串
在第一种情况下，可以简单地使用静态的 matches 方法：
代码示例：
String regex = "-]?\\d+";
CharSequence input = . . .;
if (Pattern.matches(regex, input)) {
}


如果你需要多次使用相同的正则表达式，编译它会更高效。然后，为每个输入创建一个 Matcher：
先编译，而不是通过静态方法Pattern.matches，会导致每一次执行的时候，都进行一次编译
Pattern pattern = Pattern.compile(regex);
Matcher matcher = pattern.matcher(input);
if (matcher.matches()) {
}
如果匹配成功，你可以检索所有匹配组的位置。

如果你想要匹配集合或流中的元素，可以将模式转换为一个predicate。
代码示例：
Stream<String> strings = . . .;
List<String> result = strings.filter(pattern.asPredicate()).toList();
// 这里提到的含义是 对于 集合和流 都可以把内容转换为stream 然后调用stream的filter方法即可
// 至于filter方法 他的输入参数就叫做 predicate，至于这个所谓的 predicate，是通过pattern的一个方法得到的
结果包含所有符合正则表达式的字符串。
要匹配整个字符串，可以改用 pattern.asMatchPredicate()。
// 此时的结果是 只要字符串包含这个正则表达式，就会收下这个字符串， 也可以实现 和 整个字符串进行匹配


查找输入字符串中的所有匹配项
这是另一个常见用例——在输入中查找所有匹配项。
可以使用以下循环，代码示例： 
String input = . . .;
Matcher matcher = pattern.matcher(input);
// 这里的pattern是前面编译好的字符串
while (matcher.find()) {
    String match = matcher.group();
    int matchStart = matcher.start();
    int matchEnd = matcher.end();
}
通过这种方式，您可以逐个处理每个匹配项。通过获取匹配的字符串以及它在输入字符串中的位置。


更优雅的是，您可以调用 results 方法来获取一个 Stream<MatchResult>。MatchResult 接口具有 group、start 和 end 方法，就像 Matcher 一样。（实际上，Matcher 类实现了这个接口。）
代码示例： 
List<String> matches = pattern.matcher(input)
    .results()
    .map(Matcher::group)
    .toList();
如果您的数据在一个文件中，您可以使用 Scanner.findAll 方法来获取一个 Stream<MatchResult>，而无需先将内容读取到字符串中。您可以传递一个 Pattern 或者一个模式字符串：

Scanner in = new Scanner(path, "UTF-8");
Stream<String> words = in.findAll("\\pL+")
    .map(MatchResult::group);

\\p 是一个 Unicode 属性的语法，表示匹配特定类别的字符。
L 表示字母（Letter）。所以 \\pL 匹配任何类型的字母字符，包括大写字母、小写字母、以及其他语言的字母。
+ 表示前面的模式（在这里是 \\pL）可以出现一次或多次。
总的来说，"\\pL+" 可以用来匹配连续的字母序列，不论它们属于哪种语言。



分组提取
常见做法是使用分组来提取匹配的组件。

假设您在发票中有一行项目，包括商品名称、数量和单价，如下所示：
Blackwell Toaster USD29.95

这里有一个正则表达式为每个组件定义了分组：
(\p{Alnum}+(\s+\p{Alnum}+*)\s+([A-Z]{3})([0-9.]*)

匹配后，您可以通过以下方式从匹配器中提取第 n 个分组：
String contents = matcher.group(n);

分组是按照它们的开括号顺序排序的，从 1 开始。（分组 0 是整个输入。）在此示例中，以下是如何拆分输入的方式： 
Matcher matcher = pattern.matcher(input);
if (matcher.matches()) {
    item = matcher.group(1);
    currency = matcher.group(3);
    price = matcher.group(4);
}

我们对分组 2 不感兴趣；它仅仅是由于重复所需的括号而产生的。为了更清晰，您可以使用非捕获组：
(\p{Alnum}+(?:\s+\p{Alnum}+*)\s+([A-Z]{3})([0-9.]*)

或者，更好的是，通过名称来捕获：
(?<item>\p{Alnum}+(\s+\p{Alnum}+*)\s+(?<currency>[A-Z]{3})(?<price>[0-9.]*)

这样，您就可以通过名称检索项目： 
item = matcher.group("item");

使用 start 和 end 方法，您可以获取输入中分组的位置：
int itemStart = matcher.start("item");
int itemEnd = matcher.end("item");

注意事项： 通过名称检索分组仅适用于 Matcher，而不适用于 MatchResult。

注意： 当您在重复中有一个分组时，例如上面的 (\s+\p{Alnum}+)*，无法获取所有匹配项。group 方法仅返回最后一个匹配项，这通常不太有用。您需要用另一个分组捕获整个表达式。

提示： 您可以在正则表达式中添加注释。注释以 # 开始，直到行尾。这在文本块中特别有效：

 
var regex = """
([1-9]|1[0-2]) #小时
:([0-5][0-9]) #分钟
[ap]m""";
列表 2.7 提示输入一个模式，然后输入要匹配的字符串。它会打印出输入是否与模式匹配。如果输入匹配，并且模式包含分组，程序会打印出分组边界作为括号，例如。


["2020-02-01|192.168.218.218|/login.do|success", "2020-02-01|192.168.218.218|/login.do|success", "2020-02-01|192.168.210.210|/login.do|fail", "2020-02-02|192.168.210.210|/login.do|success", "2020-02-02|192.168.218.218|/login.do|success"]



